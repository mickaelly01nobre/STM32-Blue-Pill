/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f1xx.h"

/*
 * EXTI0 external interrupt handler
 */
void EXTI0_IRQHandler(void)
{
	GPIOB->ODR ^= (1<<8);
	// Clear pending
	EXTI->PR = (1 << 0);

}
/*
 * EXTI1 external interrupt handler
 */

void EXTI1_IRQHandler(void)
{
	// Do stuff
	GPIOB->ODR ^= (1 << 9);
	// Clear pending
	EXTI->PR = (1 << 1);
}

void EXTI2_IRQHandler(void)
{
	// Do stuff
	GPIOB->ODR ^= (1 << 10);
	// Clear pending
	EXTI->PR = (1 << 2);
}


int main(void)
{

	/*
	 * Para habilitar o clock de cada periferico leia a secao 7.3.7.APB2 peripheral clock enable register (RCC_APB2ENR)
	 * Clock dos Perifericos
	 */

	//habilite para usa o GPIOB clock
	RCC->APB2ENR |= (1 << 3);

	//habilite para usa o GPIOA clock
	RCC->APB2ENR |= (1 << 2);

	/*
	 * Input
	 * Para habilita um pino como entrada leia a secaoo 9.2.1.Port configuration register low
	 *Botao
	 *
	*/

	// B1
	////CNF0[3:2] = 10 e MODE0[1:0] = 00
	// 10: Input with pull-up / pull-down
	//2a. Reseta os bits [3:0]
	GPIOA->CRL &= 0xFFFFFFF0; // binario - 11111111111111111111111111110000
	//2b. Seta o bit [3]
	GPIOA->CRL |= 0xFFFFFFF8;

	//3. Configure the ODR (1-> Pull UP, 0-> Pull down)
	// Olha a tabela com essa especificacao -> Table 20. Port bit configuration table
	//Para habilita pull-up no Input precisa configurar o registrador ODR para 1
	GPIOA->ODR |= (1<<0);


	// B2
	////CNF1[7:6] = 10 e MODE1[5:4] = 00
	// 10: Input with pull-up / pull-down
	//2a. Reseta os bits [7:0]
	GPIOA->CRL &= 0xFFFFFF0F; // binario - 11111111111111111111111100001111
	//2b. Seta o bit [7]
	GPIOA->CRL |= 0xFFFFFF80;

	//3. Configure the ODR (1-> Pull UP, 0-> Pull down)
	// Olha a tabela com essa especificacao -> Table 20. Port bit configuration table
	//Para habilita pull-up no Input precisa configurar o registrador ODR para 1
	GPIOA->ODR |= (1<<1);


	// B3
	////CNF2[11:10] = 10 e MODE2[9:8] = 00
	// 10: Input with pull-up / pull-down
	//2a. Reseta os bits [7:0]
	GPIOA->CRL &= 0xFFFFF0FF; // binario - 11111111111111111111000011111111
	//2b. Seta o bit [7]
	GPIOA->CRL |= 0xFFFFF800;

	//3. Configure the ODR (1-> Pull UP, 0-> Pull down)
	// Olha a tabela com essa especificacao -> Table 20. Port bit configuration table
	//Para habilita pull-up no Input precisa configurar o registrador ODR para 1
	GPIOA->ODR |= (1<<2);

	/*
		 * Output
		 * Para habilita um pino como saida olhe a secaoo 9.2.2 Port configuration register high (GPIOx_CRH)
		 * LED
		 *
	*/
	//LED1
	//CNF8[3:2] = 00 e MODE8[1:0] = 10
	GPIOB->CRH &= 0xFFFFFF0; // binario - 11111111111111111111111111110000
	//habilita o bit [1]
	GPIOB->CRH |= (1<<1);

	// Reset GPIOB Pin8
	GPIOB->ODR &= ~(1<<8);


	//LED2
	//CNF9[7:6] = 00 e MODE9[5:4] = 10
	GPIOB->CRH &= 0xFFFFF0F; // binario - 11111111111111111111111100001111
	//habilita o bit [5]
	GPIOB->CRH |= (1<<5);

	// Reset GPIOB Pin9
	GPIOB->ODR &= ~(1<<9);


	//LED3
	//CNF10[11:10] = 00 e MODE10[9:8] = 10
	GPIOB->CRH &= 0xFFFF0FF; // binario - 11111111111111111111000011111111
	//habilita o bit [5]
	GPIOB->CRH |= (1<<9);

	// Reset GPIOB Pin9
	GPIOB->ODR &= ~(1<<10);


	/*************>>>>>>> External Interrupt <<<<<<<<************

	1. Enable the AFIO bit in RCC register
	2. Configure the EXTI configuration Register in the AFIO
	3. Disable the EXTI Mask using Interrupt Mask Register (IMR)
	4. Configure the Rising Edge / Falling Edge Trigger
	5. Set the Interrupt Priority
	6. Enable the interrupt

	********************************************************/

	//1. Enable the AFIO bit in RCC register
	// habilita o AFIO bit do RCC register na secao 8.3.7
	RCC->APB2ENR |= (1<<0);

	//2. Configure the EXTI configuration Register in the AFIO
	// habilita AFIO na secao 9.4.3.External interrupt configuration register 1
	// habilita 0000: PA[x] pin
	// EXTI0
	AFIO->EXTICR[0] &= ~(0xf<<0);

	// EXTI1
	AFIO->EXTICR[0] &= ~(0xf<<4);

	// EXTI2
	AFIO->EXTICR[0] &= ~(0xf<<8);


	//4. Configure the  Falling Edge Trigger
	// Para habilita a borda de descida utilize a secao 10.3.4 Falling trigger selection register (EXTI_FTSR)
	// habilite 1: Falling trigger enabled (for Event and Interrupt) for input line.
	//PINO A0
	EXTI->FTSR |= (1<<0);  // Enable Falling Edge Trigger

	//PINO A1
	EXTI->FTSR |= (1<<1);  // Enable Falling Edge Trigger

	//PINO A2
	EXTI->FTSR |= (1<<2);  // Enable Falling Edge Trigger



	//3. Disable the EXTI Mask using Interrupt Mask Register (IMR)
	// Para desabilita a mascara de interrupcao utilize a secao e 10.3.1 Interrupt mask register (EXTI_IMR)
	// habilita 1: Interrupt request from Line x is not masked
	EXTI->IMR |= (1<<0); // Mask EXTI0

	EXTI->IMR |= (1<<1); // Mask EXTI1

	EXTI->IMR |= (1<<2); // Mask EXTI2

	//5. Set the Interrupt Priority
	NVIC_SetPriority(EXTI0_IRQn,1);

	//5. Set the Interrupt Priority
	NVIC_SetPriority(EXTI1_IRQn,2);

	//5. Set the Interrupt Priority
	NVIC_SetPriority(EXTI2_IRQn,3);

	//6. Enable the interrupt
	NVIC_EnableIRQ(EXTI0_IRQn);

	//6. Enable the interrupt
	NVIC_EnableIRQ(EXTI1_IRQn);

	//6. Enable the interrupt
	NVIC_EnableIRQ(EXTI2_IRQn);

	__enable_irq();


    /* Loop forever */
	for(;;);

}
