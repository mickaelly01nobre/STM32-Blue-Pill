/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint16_t adcValues[3];  // Variável global para armazenar os valores do ADC via DMA (dois canais)

#include "stm32f1xx.h"
void ADC_Init (void)
{
	/************** STEPS TO FOLLOW *****************
		1. Enable ADC and GPIO clock
		2. Set the prescalar in the Clock configuration register (RCC_CFGR)
		3. Set the Scan Mode and Resolution in the Control Register 1 (CR1)
		4. Set the Continuous Conversion, EOC, and Data Alignment in Control Reg 2 (CR2)
		5. Set the Sampling Time for the channels in ADC_SMPRx
		6. Set the Regular channel sequence length in ADC_SQR1
		7. Set the Respective GPIO PINs in the Analog Mode
		8. Enable DMA for ADC
		************************************************/

		// 1. Enable ADC and GPIO clock
		RCC->APB2ENR |= (1<<9);
		RCC->APB2ENR |= (1<<2); // GPIOA

		//2. Set the prescalar in the Clock configuration register (RCC_CFGR)
		RCC->CFGR |= (2<<14);  // Prescaler 6, ADC Clock = 72/6 = 12 MHz

		//3. Set the Scan Mode and Resolution in the Control Register 1 (CR1)
		ADC1->CR1 = (1<<8);    // SCAN mode enabled
		// Resolution is 12 bit in F103

		/*
		 * No modo de conversão contínua, o ADC inicia outra conversão assim que termina uma.
		 * Este modo é iniciado por um gatilho externo ou pela configuração do bit ADON no registrador
		 * ADC_CR2, enquanto o bit CONT é 1.
		 * */
		//4. Set the Continuous Conversion, EOC, and Data Alignment in Control Reg 2 (CR2)
			ADC1->CR2 = (1<<1);     // enable continuous conversion mode
			// EOC after each conversion by default
			ADC1->CR2 |= (7<<17);  // External Event selection pointed to SWSTART bit
			ADC1->CR2 &= ~(1<<11);   // Data Alignment RIGHT

		//Cada canal pode ser definido com um tempo de amostragem/frequência diferente.
		//	Isso pode ser controlado no registro de tempo de amostragem do ADC
		//5. Set the Sampling Time for the channels
			ADC1->SMPR2 &= ~((7<<3) | (7<<6)| (7<<12));  // Sampling time of 1.5 cycles for channel 1 and channel 4 and channel 2

		// L pode ser usado para definir o número de canais.
		//	Podemos definir o número de canais entre 1 e 16.
		//6. Set the Regular channel sequence length in ADC_SQR1
			ADC1->SQR1 |= (3<<20);   // SQR1_L =3 for 16 conversions

		//7. Set the Respective GPIO PINs in the Analog Mode
			GPIOA->CRL &= ~(0xf<<4);  // analog mode for PA 1
			GPIOA->CRL &= ~(0xf<<16); // analog mode for PA 4
			GPIOA->CRL &= ~(0xf<<8); // analog mode for PA 2

		//8. Enable DMA for ADC
		ADC1->CR2 |= (1<<8);

		//	// Enable Continuous Request
		//	ADC1->CR2 |= (1<<9);

		// Também precisamos definir a sequência para a conversão.
		// Como qual canal será convertido primeiro, qual será convertido em segundo,
		// e assim por diante.
		// Channel Sequence
		ADC1->SQR3 |= (1<<0);  // SEQ1 for Channel 1
		ADC1->SQR3 |= (4<<5);  // SEQ2 for CHannel 4
		ADC1->SQR3 |= (2<<10);  // SEQ3 for CHannel 2
}

/* Uma vez que a configuração do ADC esteja completa, nós habilitaremos o ADC.
 * Isso é importante para habilitá-lo no final porque não podemos configurar
 * certas coisas enquanto o ADC estiver habilitado.
 *
 */

void ADC_Enable (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable the ADC by setting ADON bit in CR2
	2. Wait for ADC to stabilize (approx 10us)
	************************************************/
	ADC1->CR2 |= 1<<0;   // ADON =1 enable ADC1

	uint32_t delay = 10000;
	while (delay--);
}

void ADC_Start(void)
{
	/************** STEPS TO FOLLOW *****************
	1. Clear the Status register
	2. Start the Conversion by Setting the SWSTART bit in CR2

	 Iniciaremos o ADC para iniciar a conversão dos canais selecionados.
	*************************************************/
	ADC1->SR = 0;                      // Clear Status register
	ADC1->CR2 |= (1<<20);              // Conversion on external event enabled
	ADC1->CR2 |= 1<<22;                // Start conversion
}
void PWM_Init(void)
{
    // Habilitar o clock para o GPIOB e TIM3
    RCC->APB2ENR |= (1 << 3); // Habilitar clock do GPIOB
    RCC->APB1ENR |= (1 << 1); // Habilitar clock do TIM3

    // Configurar os pinos GPIOB 8, 9, 10 como saída alternativa para PWM (modo push-pull)
    GPIOB->CRH &= ~(0xFFF << 0);  // Limpar os bits de configuração dos pinos 8, 9 e 10
    GPIOB->CRH |= (0xAAA << 0);   // Configurar os pinos 8, 9, 10 como saída alternativa, 50MHz

    // Configurar o temporizador TIM3 para modo PWM
    TIM3->PSC = 72 - 1; // Prescaler para obter clock de 1 MHz
    TIM3->ARR = 4095;   // Contagem máxima para correspondência com valor do ADC (12 bits)

    // Modo PWM no canal 3 (PB0), canal 4 (PB1) e canal 2 (PB10)
    TIM3->CCMR1 |= (6 << 12) | (6 << 4); // PWM mode 1 para CH2 e CH3
    TIM3->CCMR2 |= (6 << 4);             // PWM mode 1 para CH4

    TIM3->CCER |= (1 << 4) | (1 << 8) | (1 << 12); // Habilitar os canais de saída CH2, CH3 e CH4

    TIM3->CR1 |= (1 << 0); // Habilitar o contador
}
void PWM_SetDutyCycle(uint16_t red, uint16_t green, uint16_t blue)
{
    // Definir valores do ciclo de trabalho (duty cycle) para o PWM
    TIM3->CCR2 = red;
    TIM3->CCR3 = green;
    TIM3->CCR4 = blue;
}

int main(void)
{
	//habilite para usa o GPIOB clock
	RCC->APB2ENR |= (1 << 3);

    // Configura os pinos GPIOB 8, 9 e 10 como saída
    GPIOB->CRH &= 0xFFFFF000; // Limpa os bits de configuração dos pinos 8, 9 e 10
    GPIOB->CRH |= 0x00000222; // Configura os pinos 8, 9 e 10 como saída push-pull, máxima velocidade de 2 MHz

	ADC_Init ();
	ADC_Enable ();


	/************** STEPS TO FOLLOW *****************
	 	 	 DMA Init
	1. Enable DMA clock
	2. Set the DATA Direction
	3. Enable/Disable the Circular Mode
	4. Enable/Disable the Memory Increment and Peripheral Increment
	5. Set the Data Size
	6. Select the channel for the Stream

	13.4.3 DMA channel x configuration register (DMA_CCRx) (x = 1..7, where x = channel number)
	************************************************/

	// 1. Enable DMA1 Clock
	RCC->AHBENR |= 1<<0;

	// 2. Set the Data Direction
//	DMA1_Channel7->CCR |= (1<<4);   // Read From Memory
	DMA1_Channel1->CCR &= ~(1<<4);   // Read From Peripheral

	// 2. Enable the circular mode (CIRC)
	DMA1_Channel1->CCR |= 1<<5;

	// 3. Enable the Memory Increment (MINC)
	DMA1_Channel1->CCR |= 1<<7;

	// 4. Set the Peripheral data size (PSIZE)
	DMA1_Channel1->CCR |= (1<<8);  // 01 : 8 Bit Data

	// 5. Set the Memory data size (MSIZE)
	DMA1_Channel1->CCR |= (1<<10);  // 01 : 8 Bit Data

	/************** STEPS TO FOLLOW *****************
	 	 	 	 	 DMA Configutation
	1. Set the Data Size in the CNDTR Register
	2. Set the Peripheral Address and the Memory Address
	3. Enable the DMA Stream

		 Some peripherals don't need a start condition, like UART, So as soon as you enable the DMA, the transfer will begin
		 While Peripherals like ADC needs the Start condition, so Start the ADC later in the program, to enable the transfer
	************************************************/

	/*
	 * Quantidade de dados a serem transferidos (de 0 até 65535). Este registrador só pode ser escrito quando o canal está desativado.
	 * Uma vez que o canal é ativado, este registrador se torna somente leitura, indicando os bytes restantes a serem transmitidos.
	 * Este registrador decrementa após cada transferência de DMA. Quando a transferência é concluída, este registrador pode permanecer
	 * em zero ou ser recarregado automaticamente pelo valor previamente programado, se o canal estiver configurado no modo de recarga automática.
	 * Se este registrador estiver em zero, nenhuma transação pode ser atendida, independentemente de o canal estar ativado ou não.
	 *
	 */
	DMA1_Channel1->CNDTR = 3;   // Set the size of the transfer

	// Endereço base do registrador de dados do periférico de/para o qual os dados serão lidos/escritos.
	DMA1_Channel1->CPAR = (uint32_t)&ADC1->DR;  // Source address is peripheral address

	// Base address of the memory area from/to which the data will be read/written
	DMA1_Channel1->CMAR = (uint32_t)&adcValues;  // Destination Address is memory address

	// Enable the DMA Stream
	DMA1_Channel1->CCR |= (1<<0);  // EN =1

	ADC_Start ();

    // Define um limiar para os valores do ADC (ajuste conforme necessário)
    uint16_t limiar1 = 2000;  // Limiar para o canal 1 (PA1)
    uint16_t limiar2 = 2500;  // Limiar para o canal 4 (PA4)
    uint16_t limiar3 = 1500;  // Limiar para o canal 2 (PA2)


    while (1)
    {
    	// Verificar o valor do primeiro ADC (PA1) e acionar apenas o LED correspondente (PB8)
    		if (adcValues[0] > limiar1)
    		{
    			GPIOB->BSRR |= (1 << 8); // Acender LED no PB8
    		}
    		else
    		{
    			GPIOB->BRR |= (1 << 8); // Apagar LED no PB8
    		}

    		// Verificar o valor do segundo ADC (PA4) e acionar apenas o LED correspondente (PB9)
    		if (adcValues[1] > limiar2)
    		{
    			GPIOB->BSRR |= (1 << 9); // Acender LED no PB9
    		}
    		else
    		{
    			GPIOB->BRR |= (1 << 9); // Apagar LED no PB9
    		}
    		// Verificar o valor do segundo ADC (PA4) e acionar apenas o LED correspondente (PB9)
    		if (adcValues[2] > limiar3)
    		{
    			GPIOB->BSRR |= (1 << 10); // Acender LED no PB9
    		}
    		else
    		{
    			GPIOB->BRR |= (1 << 10); // Apagar LED no PB9
    		}
    }
}
